#!/usr/bin/env ruby

require "optparse"
require "optparse/uri"
require "io/console"
require "webrick"
require "stringio"
require "uri"
require "net/http"
require "securerandom"
require "digest"
require "base64"

options = {
  site: URI("https://frobozz.social").freeze,
  client_id: "frobozz-client"
}
parser = OptionParser.new do |parser|
  parser.banner = "Usage: #{$0} <command> [options]"
  parser.on "-h", "--help", "Get help" do
    puts parser
    exit
  end
  parser.on "-sSITE", "--site=SITE", "--server", "Specify site to connect", URI do |site|
    options[:site] = site.freeze
  end
  parser.on "--client-id=CLIENT_ID", "Override client ID", String do |client_id|
    options[:client_id] = client_id.freeze
  end
end
parser.parse!

command = ARGV.shift

case command
when "login"
  server_logger = WEBrick::Log.new(StringIO.new) # shush
  redirect_server = WEBrick::HTTPServer.new(Port: 0, Logger: server_logger)
  loopback_uri = "http://127.0.0.1:#{redirect_server.config[:Port]}"

  pkce_legal_characters = [*("A".."Z"), *("a".."z"), *("0".."9"), "-", ".", "_", "~"].freeze
  # Note that Array#sample(n, ...)  tries to sample *unique* indices, so it is
  # not suitable here.
  pkce_verifier = Array.new(64) { pkce_legal_characters.sample(random: SecureRandom) }.join
  pkce_challenge = Base64.urlsafe_encode64(Digest::SHA256.digest(pkce_verifier), padding: false)

  authorize_params = {}
  # standard:disable Layout
  authorize_params["response_type"]         = "code"
  authorize_params["client_id"]             = options[:client_id]
  authorize_params["redirect_uri"]          = loopback_uri
  authorize_params["scope"]                 = "profile.read profile.write realm.read realm.write"
  authorize_params["code_challenge"]        = pkce_challenge
  authorize_params["code_challenge_method"] = "S256"
  # standard: enable Layout

  authorize_url = URI(options[:site]).dup
  authorize_url.path = "/oauth/authorize"
  authorize_url.query = URI.encode_www_form(authorize_params)

  puts "Please visit: #{authorize_url}"
  puts "Waiting for confirmation..."
  auth_code = nil
  redirect_server.mount_proc "/" do |req, res|
    if (error_code = req.query["error"])
      puts "Authorization error: #{error_code}"
      if (error_desc = req.query["error_description"])
        puts error_desc
      end
      if (error_uri = req.query["error_uri"])
        puts "More info: #{error_uri}"
      end
      res.content_type = "text/plain"
      res.body = "Failed. You can close this window now."
    else
      auth_code = req.query["code"]
      res.content_type = "text/plain"
      res.body = "Success! You can close this window now."
    end
    redirect_server.shutdown
  end
  redirect_server.start

  token_url = URI(options[:site]).merge("/oauth/token")
  token_params = {}
  # standard:disable Layout
  token_params["grant_type"]    = "authorization_code"
  token_params["code"]          = auth_code
  token_params["redirect_uri"]  = loopback_uri
  token_params["client_id"]     = options[:client_id]
  token_params["code_verifier"] = pkce_verifier
  # standard: enable Layout
  token_body = URI.encode_www_form(token_params)
  token_headers = {}
  token_headers["Content-Type"] = "application/x-www-form-urlencoded"
  token_headers["Accept"] = "application/json"
  token_response = Net::HTTP.post(token_url, token_body, token_headers)
  pp token_response
  pp token_response.body
  #   #<Net::HTTPOK 200 OK readbody=true>
  # "{\"access_token\":\"6b2_aW_vRHK-wdGkCPwIMyP6AmmngVQyncOKAV2tbv8\",\"token_type\":\"bearer\",\"expires_in\":3600,\"refresh_token\":\"J0ZfUNkl6OY5RcvzfEo_NnVfOOEYeuvWoanoZPqkJPI\"}"
else
  puts "I don't know how to #{command}"
  abort
end
